#!/usr/bin/env bash

# dd-upload-artifacts
#
# upload build artifacts to distribution server
#
# author  : stefan schablowski
# contact : stefan.schablowski@desmodyne.com
# created : 2016-06-02


echo
echo 'dd-upload-artifacts:'
echo

# -----------------------------------------------------------------------------
# determine platform: http://stackoverflow.com/a/18434831

case "${OSTYPE}" in
    linux*)
        dist_name=$(lsb_release --id --short)

        res="$?"

        if [ "${res}" -eq 0 ]
        then
            # make sure this is run only on Debian / Ubuntu systems
            if [ "${dist_name}" != 'Debian' ] && [ "${dist_name}" != 'Ubuntu' ]
            then
                echo "Unsupported Linux distribution: ${dist_name}"
                exit -1
            fi
        else
            echo "Could not determine Linux distribution name"
            exit "${res}"
        fi

        # ping return code 2 is too generic to be useful
        ping_code=2

        # ping error message for recoverable problem;
        ping_err_msg_tmpl='ping: unknown host %s'

        # NOTE: on OSX, BSD (?) ping is different:
        # alexa:~ ssc$ ping -c 1 bogushost
        # ping: cannot resolve bogushost: Unknown host
        # alexa:~ echo $?
        # 68

        ;;
    *)
        echo "Unsupported operating system: ${OSTYPE}"
        exit -1
        ;;
esac


# ----------------------------------------a-------------------------------------
# process command line arguments

# TODO: support passing distribution channel as second argument ?

# if [ ! -z "$2" ]
# then
#     # TODO: test channel is supported
#     distribution_channel="$1"
#     message="using command line argument, sync'ing to ${distribution_channel} channel at"
# fi

if [ $# -ne 1 ]
then
    echo "Usage: $(basename "$0") <repository root folder>"
    exit -1
else
    if [ ! -e "$1" ]
    then
        echo "$1: No such file or directory"
        exit -1
    fi
    if [ ! -d "$1" ]
    then
        echo "$1: Not a directory"
        exit -1
    fi
fi


# -----------------------------------------------------------------------------
# configure script parameters

# absolute path to the root folder of the repository to process
# on Debian, install realpath using e.g. aptitude install realpath
# on OS X, use grealpath: http://apple.stackexchange.com/a/88812
repo_root="$(realpath "$1")"

# absolute path to target project configuration
project_conf="${repo_root}/project.json"

# these assume packages being uploaded were built on this host
# and there is no "cross-package-building" taking place, ie.
# no creating Debian 32-bit packages on a Ubuntu 64-bit host

# determine Linux distribution (e.g. Debian, Ubuntu)
# TODO: shellcheck seems to be a little overactive here...
# shellcheck disable=SC2034
distribution=$(lsb_release --id --short | tr '[:upper:]' '[:lower:]')

# determine architecture to determine distribution bitness (e.g. i386, amd64)
arch=$(arch)

if   [[ "${arch}" == 'i686' ]]
then
    # shellcheck disable=SC2034
    distribution_folder='binary-i386'
elif [[ "${arch}" == 'x86_64' ]]
then
    # shellcheck disable=SC2034
    distribution_folder='binary-amd64'
else
    echo "Unsupported architecture ${arch}"
    exit -1
fi

# archive area: http://askubuntu.com/a/27514
# https://www.debian.org/doc/debian-policy/ch-archive.html
# shellcheck disable=SC2034
archive_area='non-free'

# determine git branch or target project to determine distribution channel
git_branch=$(git -C "${repo_root}" rev-parse --symbolic-full-name --abbrev-ref HEAD)

if [[ "${git_branch}" != 'develop' && \
      "${git_branch}" !=  feature* && \
      "${git_branch}" != 'master'  && \
      "${git_branch}" !=  release* ]]
then
    echo "Unsupported git branch / distribution channel ${git_branch}"
    exit -1
fi

if   [[ "${git_branch}" ==  'develop' ]]
then
    # shellcheck disable=SC2034
    distribution_channel='develop'
elif [[ "${git_branch}" ==   feature* ]]
then
    # shellcheck disable=SC2034
    distribution_channel='feature'
elif [[ "${git_branch}" ==  'master'  ]]
then
    # shellcheck disable=SC2034
    distribution_channel='master'
elif [[ "${git_branch}" ==   release* ]]
then
    # shellcheck disable=SC2034
    distribution_channel='release'
fi

# mapping of distribution channel to name
# and SSH key of user with write privileges
# NOTE: shellcheck doesn't seem to cope well with alternate notation
# declare -A channel_2_user_map= ... -  SC1007, SC2034 plus
# ^-- SC1070: Parsing stopped here because of parsing errors.
# ^-- SC1036: '(' is invalid here. Did you forget to escape it?

declare -A channel_2_user_map

channel_2_user_map["develop"]="bob.the.builder:id_rsa_bob.the.builder"
channel_2_user_map["feature"]="dd:id_rsa_desmodyne"
channel_2_user_map["master"]="bob.the.builder:id_rsa_bob.the.builder"
channel_2_user_map["release"]="bob.the.builder:id_rsa_bob.the.builder"

user_info="${channel_2_user_map[${distribution_channel}]}"

# full path to and name of SSH private key file used to log into remote server
ssh_key="$HOME/.ssh/$(echo "${user_info}" | cut -d : -f 2)"

# list of currently supported artifacts types
# TODO: this should probably come from somewhere global
supported_artifacts_types='configuration downloads packages'

# name of remote server; defined by us
# NOTE: 'update' server name is defined in DesmoDyne corporate name server
remote_server='update'

# name of the user to log in as on the remote server
remote_user="$(echo "${user_info}" | cut -d : -f 1)"

# template for first part of remote folder location; defined by us
remote_loc_tmpl='/var/www/desmodyne.com/%s/public_html/protected'

# second part of remote folder location;
# defined by Debian standard for packages; defined by us for other artifacts
declare -A remote_loc_leaves

# configuration is yet to be amended by ship name; downloads isn't used yet
# TODO: shellcheck seems to be a little overactive here...
# shellcheck disable=SC2154
remote_loc_leaves['configuration']="%s/${distribution_channel}"
# shellcheck disable=SC2154
remote_loc_leaves['downloads']=""
# shellcheck disable=SC2154
remote_loc_leaves['packages']="${distribution}/dists/${distribution_channel}/"
remote_loc_leaves['packages']+="${archive_area}/${distribution_folder}"

# rsync switches
rsync_switches='--archive --checksum --verbose'


# -----------------------------------------------------------------------------
# upload artifacts to remote server

echo -n "Test-ping remote server: "
ping_output=$(ping -c 1 "${remote_server}" 2>&1)

res="$?"

if [ "${res}" -eq 0 ]
then
    echo 'OK'
    echo
else
    ping_err_msg="$(printf "${ping_err_msg_tmpl}" "${remote_server}")"

    if [ "${res}" -eq "${ping_code}" ] && \
       [ "${ping_output}" = "${ping_err_msg}" ]
    then
        echo "${ping_output}"
        echo "Maybe add a line '<IP address>  ${remote_server}' to /etc/hosts ?"
    else
        echo "unexpected failure:"
        echo "${ping_output}"
    fi

    echo
    exit -1
fi

echo "Repository at ${repo_root} is on git branch ${git_branch},"
echo "upload to ${distribution_channel} channel"
echo

if [ ! -r "${ssh_key}" ]
then
    echo "Would use SSH key ${ssh_key} to connect, but failed to find file."
    exit -1
fi

echo "Use SSH key ${ssh_key} to connect"

if [ -z "${SSH_AGENT_PID}" ] || [ -z "${SSH_AUTH_SOCK}" ]
then
    echo -n "  start new SSH agent: "
    # TODO: output SSH_AGENT_PID and SSH_AUTH_SOCK of new agent
    # TODO: mute eval output > /dev/null
    # ssh-agent -s sample output:
    #   SSH_AUTH_SOCK=/tmp/ssh-ieIVK1IGVv29/agent.25687; export SSH_AUTH_SOCK;
    #   SSH_AGENT_PID=25688; export SSH_AGENT_PID;
    #   echo Agent pid 25688;
    # eval "$(ssh-agent -s)" sample output:
    #   Agent pid 25688
    eval "$(ssh-agent -s)"
else
    echo "  re-use SSH agent with PID ${SSH_AGENT_PID} at ${SSH_AUTH_SOCK}"
fi

# TODO: check key fingerprint instead of key filename
# ssh-add -l sample output (wrapping indicated by ... ):
# 4096 36:ab:bc:9f:93:c2:ee:8f:51:0b:b4:a1:46:96:d3:7f ...
#  ... /home/ssc/.ssh/id_rsa_bob.the.builder (RSA)

current_keys="$(ssh-add -l)"

if [[ " ${current_keys} " =~ " ${ssh_key} " ]]
then
    echo "  re-use existing identity represented by SSH agent"
else
    # TODO: align ssh-add output with convention
    echo -n '  no matching identities found: '
    ssh-add "${ssh_key}"
fi

echo

artifacts_json="$(jq '.Artifacts' "${project_conf}")"
artifacts_types="$(echo "${artifacts_json}" | jq -r 'keys[]' )"

for artifacts_type in ${artifacts_types}
do
    # http://stackoverflow.com/a/8063398
    # shellcheck disable=SC2076
    if [[ ! " ${supported_artifacts_types} " =~ " ${artifacts_type} " ]]
    then
        echo "Unsupported artifact type ${artifacts_type}"
        continue
    fi

    echo "${artifacts_type}:"
    echo

    # TODO: support globs ?

    # local folder to upload, relative to target project root
    rel_local_folder="$(echo "${artifacts_json}" | jq -r ".${artifacts_type}")"

    # absolute path to local folder to upload
    abs_local_folder="${repo_root}/${rel_local_folder}"

    if [ ! -e "${abs_local_folder}" ]
    then
        echo "${abs_local_folder}: No such file or directory"
        continue
    fi
    if [ ! -d "${abs_local_folder}" ]
    then
        echo "${abs_local_folder}: Not a directory"
        continue
    fi

    local_folder="$(realpath "${abs_local_folder}")"

    # remote server and folder to upload to
    remote_loc_leaf="${remote_loc_leaves[$artifacts_type]}"

    if [ "${artifacts_type}" = 'configuration' ]
    then
        ship_name="$(jq -r '.ShipName' "${project_conf}")"
        # shellcheck disable=SC2059
        remote_loc_leaf=$(printf "${remote_loc_leaf}" "${ship_name}")
    fi

    # shellcheck disable=SC2059
    remote_loc=$(printf "${remote_loc_tmpl}" "${artifacts_type}")
    remote_location="${remote_user}@${remote_server}:"
    remote_location+="${remote_loc}/${remote_loc_leaf}"

    printf "sync %s\nto   %s:\n" "${local_folder}" "${remote_location}"
    echo "rsync ${rsync_switches} ${local_folder}/ ${remote_location}"
    # shellcheck disable=SC2086
    rsync ${rsync_switches} "${local_folder}/" "${remote_location}"
done


echo
echo 'dd-upload-artifacts: success'
echo

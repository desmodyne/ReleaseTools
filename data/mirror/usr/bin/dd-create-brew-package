#!/usr/bin/env bash

# dd-create-brew-package
#
# create brew package
#
# author  : stefan schablowski
# contact : stefan.schablowski@desmodyne.com
# created : 2016-07-08


echo
echo 'dd-create-brew-package:'
echo

# -----------------------------------------------------------------------------
# determine platform: http://stackoverflow.com/a/18434831

# NOTE: technically, brew packages can be built on Linux as much as on OS X;
# restricting execution platforms to OS X here keeps things a lot simpler:
# if this runs on OS X only, we will not encounter both brew and Debian packages

case "${OSTYPE}" in
    darwin*)
        grep='ggrep'
        sed='gsed'
        ;;
    *)
        echo "Unsupported operating system: ${OSTYPE}"
        exit -1
        ;;
esac


# -----------------------------------------------------------------------------
# process command line arguments

if [ $# -ne 1 ]
then
    echo "Usage: $(basename "$0") <repository root folder>"
    exit -1
else
    if [ ! -e "$1" ]
    then
        echo "$1: No such file or directory"
        exit -1
    fi
    if [ ! -d "$1" ]
    then
        echo "$1: Not a directory"
        exit -1
    fi
fi


# TODO: error handling
# TODO: prevent processing repo this file is in during development ?
# TODO: verify required executables are available before using them ?
# TODO: script return value when run as Jenkins job ?!?


# -----------------------------------------------------------------------------
# configure script parameters

# name of this script: http://stackoverflow.com/q/192319
script_name="$(basename "$0")"

# absolute path to the root folder of the repository to process
# on Debian, install realpath using e.g. aptitude install realpath
# on OS X, use grealpath: http://apple.stackexchange.com/a/88812
repo_root="$(realpath "$1")"

# absolute path to target project configuration
project_conf="${repo_root}/project.json"

# name of target project
project_name="$(jq -r '.Project' "${project_conf}")"

# package output folder, relative to target project root
package_folder="$(jq -r '.Artifacts.packages' "${project_conf}")"

# for single-package projects, package name is project name in lower case;
# for multi-package projects, package names are determined further below
package_name="$(echo "${project_name}" | tr '[:upper:]' '[:lower:]')"

# TODO: instead of pulling package version out of the CMake file, it should
# be stored in project.json from where it can be retrieved much easier and
# both the CMake file as well as this code should obtain it from there;
# however, this requires the patch version bumping to be refactored, tool
# which especially for multi-package project is not trivial

# NOTE: see also dd-bump-patch-version

# path to CMake / CPack config file, relative to root of target project
path_to_cmake_conf="build/CMakeLists.txt"

# regular expression pattern for line defining major version
major_regex='(set\(CPACK_PACKAGE_VERSION_MAJOR\s+")([0-9]+)("\))'

# regular expression pattern for line defining minor version
minor_regex='(set\(CPACK_PACKAGE_VERSION_MINOR\s+")([0-9]+)("\))'

# regular expression pattern for line defining patch version
patch_regex='(set\(CPACK_PACKAGE_VERSION_PATCH\s+")([0-9]+)("\))'

# git archive format; see git archive --list for supported formats
git_archive_format='tar.gz'

# git branch of target project
git_branch=$(git -C "${repo_root}" rev-parse --symbolic-full-name --abbrev-ref HEAD)


# -----------------------------------------------------------------------------
# create brew package


# change to target project root directory
pushd "${repo_root}" > /dev/null


# delete files OS X keeps creating so they are not added to the package;
# this occurs with project spaces shared between OSs, e.g. using sshfs
# TODO: is this really required ? git archive knows its files...
find . \( -iname '._*' -or -iname '.DS_Store' \) -delete

# remove and (re-) create temporary working folder
if [ -d "${package_folder}" ]
then
    rm -r "${package_folder}"
fi
mkdir -p "${package_folder}"


major_line=$("${grep}" -E "${major_regex}" "${path_to_cmake_conf}")
minor_line=$("${grep}" -E "${minor_regex}" "${path_to_cmake_conf}")
patch_line=$("${grep}" -E "${patch_regex}" "${path_to_cmake_conf}")

major_version="$(echo "${major_line}" | "${sed}" -r -e "s|${major_regex}|\2|g")"
minor_version="$(echo "${minor_line}" | "${sed}" -r -e "s|${minor_regex}|\2|g")"
patch_version="$(echo "${patch_line}" | "${sed}" -r -e "s|${patch_regex}|\2|g")"

archive_name="${package_name}"
archive_name+=".${major_version}.${minor_version}.${patch_version}"
archive_name+=".${git_archive_format}"

git archive --format="${git_archive_format}"              \
            --output="${package_folder}/${archive_name}"  \
            "${git_branch}"
res="$?"; if [ "${res}" -ne 0 ]; then exit "${res}"; fi


# change back to previous location
popd > /dev/null


echo
echo "dd-create-brew-package: success"
echo

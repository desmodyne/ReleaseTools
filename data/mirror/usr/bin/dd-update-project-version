#!/usr/bin/env bash

# dd-update-project-version
#
# update semantic version in project configuration
#
# author  : stefan schablowski
# contact : stefan.schablowski@desmodyne.com
# created : 2016-06-03


# MAJOR.MINOR.PATCH versioning: http://semver.org
# https://en.wikipedia.org/wiki/Software_versioning


echo
echo 'dd-update-project-version:'
echo

# -----------------------------------------------------------------------------
# determine platform: http://stackoverflow.com/a/18434831

# NOTE: on OS X, install GNU sed and grep using
# brew tap homebrew/dupes; brew install gnu-sed grep
# http://apple.stackexchange.com/a/69332

case "${OSTYPE}" in
    darwin*)
        # grep='ggrep'
        sed='gsed'
        ;;
    linux*)
        # grep='grep'
        sed='sed'
        ;;
    *)
        echo "Unsupported operating system: ${OSTYPE}"
        exit -1
        ;;
esac


# -----------------------------------------------------------------------------
# define functions

# TODO: this duplicates the same code in dd-release

# http://stackoverflow.com/a/6212408

function usage
{
    read -r -d '' msg_tmpl <<'EOT'
Usage: %s folder [version]

mandatory arguments:
  folder                project repository root folder

optional arguments:
  semver                semantic project version to release
  -?, --help            print this help message
EOT

    # shellcheck disable=SC2059
    printf "${msg_tmpl}\n" "${script_name}"
}


# -----------------------------------------------------------------------------
# process command line arguments

# TODO: this duplicates the same code in dd-release

# name of this script: http://stackoverflow.com/q/192319
script_name="$(basename "$0")"

# http://stackoverflow.com/a/14203146
while [ $# -gt 0 ]
do
    key="$1"

    case "${key}" in
      # NOTE: must escape -?, seems to act as wildcard otherwise
      -\?|--help) usage; exit 1 ;;

      *)  if [ -z "${folder}" ]
          then
              folder="$1"
          else
              if [ -z "${semver}" ]
              then
                  semver="$1"
              else
                  usage
                  exit 1
              fi
          fi
    esac

    # move past argument or value
    shift
done


# folder is a mandatory command line argument
if [ -z "${folder}" ]
then
    usage
    exit 1
fi


# -----------------------------------------------------------------------------
# configure script parameters

# TODO: this (almost) duplicates the corresponding code in dd-release

# regular expression that matches a semantic version:
# MAJOR.MINOR.PATCH versioning: http://semver.org
# https://en.wikipedia.org/wiki/Software_versioning

# TODO: is there any 'cross-regex dialect' way to use a single regex only ?

# TODO: this version works with bash [[ <string> =~ <regex> ]]
semver_regex_bash='^[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+$'

# TODO: this version works with sed and retrieves matches
semver_regex='^\([[:digit:]]\+\)\.\([[:digit:]]\+\)\.\([[:digit:]]\+\)$'

# -----------------------------------------------------------------------------
# validate command line arguments

# TODO: this duplicates the same code in dd-release

if [ ! -e "${folder}" ]
then
    echo "${folder}: No such file or directory"
    exit 1
fi

if [ ! -d "${folder}" ]
then
    echo "${folder}: Not a directory"
    exit 1
fi

if [ -n "${semver}" ]
then
    if [[ ! "${semver}" =~ ${semver_regex_bash} ]]
    then
        echo "${semver}: Invalid semantic version"
        exit 1
    fi
fi


# -----------------------------------------------------------------------------
# configure script parameters, cont.

# absolute path to root folder of repository to process
repo_root="$(realpath "${folder}")"

# path to project configuration file, relative to root of target project
path_to_proj_conf='project.conf'

# TODO: review path_to_proj_conf_folder vs. project_config

# absolute path to project configuration file
project_config="${repo_root}/${path_to_proj_conf}"

# path to folder with project configuration file, relative to project root
path_to_proj_conf_folder="$(dirname "${project_config}")"

# regular expression pattern template for multiple lines defining patch version
multi_line_patch_regex_tmpl='("%s"[^p]*"patch" : ")([0-9]+)(")'

# regular expression pattern for line defining major version
major_regex='([ ]+"major"[ ]+:[ ]+")([0-9]+)(")'

# regular expression pattern for line defining minor version
minor_regex='([ ]+"minor"[ ]+:[ ]+")([0-9]+)(")'

# regular expression pattern for line defining patch version
patch_regex='([ ]+"patch"[ ]+:[ ]+")([0-9]+)(")'

# message for committing changes to project configuration file
# TODO: add project and release names ?
commit_message='[#1]: update project version'


# -----------------------------------------------------------------------------
# update project version


# NOTE: pushd / popd require bash
pushd "${repo_root}" > /dev/null


project_config="${repo_root}/${path_to_proj_conf}"

echo "Update project version in ${project_config}"

# verify project configuration exists before accessing it
if [ ! -f "${project_config}" ]
then
    echo "Failed to find project configuration file: ${project_config}"
    popd > /dev/null
    exit -1
fi

# TODO: verify this works with relative paths passed as cmd line argument
# TODO: prevent processing conf of this project during development ?
# TODO: verify required executables are available before using them ?
# TODO: script return value when run as Jenkins job ?!?
# TODO: refactor this to remove code duplication
# TODO: access project config file only once

error_flag=false

# new-style project version information

# TODO: review this

version="$(jq -r '.Version' "${project_config}")"

if [ "${version}" = 'null' ]
then
    echo "Failed to find version information in ${project_config}"
    echo
    exit -1
fi

# resolve file / json element references

if [ "$(echo "${version}" | jq -r '. | keys[]')" = '_include' ]
then
    reference="$(echo "${version}" | jq -r '._include')"
    file_ref="$(echo "${reference}" | cut -d : -f 1)"
    json_ref="$(echo "${reference}" | cut -d : -f 2)"
    version="$(jq ".${json_ref}" "${path_to_proj_conf_folder}/${file_ref}")"

    path_to_version_conf="$(realpath "${path_to_proj_conf_folder}/${file_ref}")"

    # semantic version is passed as script argument
    if [ -n "${semver}" ]
    then
        # TODO: get jq filters from conf ?
        major="$(echo "${version}" | jq -r '.major')"
        minor="$(echo "${version}" | jq -r '.minor')"
        patch="$(echo "${version}" | jq -r '.patch')"

        existing_semver="${major}.${minor}.${patch}"

        # verify semver is greater than current version
        if [[ ! "${semver}" > "${existing_semver}" ]]
        then
            msg_tmpl='Version argument %s is not greater '
            msg_tmpl+='than existing version %s\ndefined in %s'
            # shellcheck disable=SC2059
            msg="$(printf "${msg_tmpl}" "${semver}"             \
                                        "${existing_semver}"    \
                                        "${path_to_version_conf}")"
            echo "${msg}"
            exit 1
        fi

        new_major="$(echo "${semver}" | "${sed}" -e "s|${semver_regex}|\1|g")"
        new_minor="$(echo "${semver}" | "${sed}" -e "s|${semver_regex}|\2|g")"
        new_patch="$(echo "${semver}" | "${sed}" -e "s|${semver_regex}|\3|g")"

        # NOTE: if single quotes are added here, sed fails with
        # gsed: -e expression #1, char 1: unknown command: `''
        sed_expr_01="s|${major_regex}|\1${new_major}\3|g"
        sed_expr_02="s|${minor_regex}|\1${new_minor}\3|g"
        sed_expr_03="s|${patch_regex}|\1${new_patch}\3|g"

        if ! "${sed}" -i -r -e "${sed_expr_01}"   \
                            -e "${sed_expr_02}"   \
                            -e "${sed_expr_03}"   \
                            "${path_to_version_conf}"
        then
            msg_tmpl='Failed to update project version in %s'
            # shellcheck disable=SC2059
            msg="$(printf "${msg_tmpl}" "${path_to_version_conf}")"
            echo "${msg}"
            exit 1
        fi


    # if no semver, only bump the patch version
    else
        # TODO: this duplicates single-package project code below
        patch_version="$(echo "${version}" | jq -r '.patch')"
        patch_version=$((patch_version + 1))

        if ! "${sed}" -i -r -e "s|${patch_regex}|\1${patch_version}\3|g" \
                               "${path_to_version_conf}"
        then
            msg_tmpl='Failed to update patch version in %s\n'
            # shellcheck disable=SC2059
            msg="$(printf "${msg_tmpl}" "${path_to_version_conf}")"
            echo "${msg}"
            exit 1
        fi
    fi

    target_file="${path_to_version_conf}"


elif [ "$(jq '.Version.major' "${project_config}")" = 'null' ] &&
     [ "$(jq '.Version.minor' "${project_config}")" = 'null' ] &&
     [ "$(jq '.Version.patch' "${project_config}")" = 'null' ]
then

    # multi-package project

    # TODO: plausibility check against .../packages/* ?
    # TODO: package names in project.conf use _, folder names use -
    package_names="$(jq -r '.Version | keys []' "${project_config}")"

    for package_name in ${package_names}
    do
        # get current patch version number and increment it
        patch_version="$(jq -r ".Version.${package_name}.patch" \
                               "${project_config}")"

        res="$?"

        # TODO: if [ -z "${patch_version}" ] ?

        if [ "${res}" -ne 0 ]
        then
            message="Failed to get package version patch number from "
            message+=".Version.${package_name}.patch JSON attribute in "
            message+="project configuration file ${project_config}"
            echo "${message}"
            error_flag=true
            continue
        fi

        patch_version=$((patch_version + 1))

        # replace current with new patch version
        # shellcheck disable=SC2059
        patch_regex="$(printf "${multi_line_patch_regex_tmpl}" \
                              "${package_name}")"

        # http://unix.stackexchange.com/a/152389 <--- !!!
        # NOTE: it doesn't seem possible to modify the JSON file
        # in place; see also http://stackoverflow.com/a/24943373
        # NOTE: see also: http://unix.stackexchange.com/a/204378
        # shellcheck disable=SC2002
        json_data="$(cat "${project_config}" \
          | tr '\n' '\r'                     \
          | "${sed}" -r -e "s|${patch_regex}|\1${patch_version}\3|g" \
          | tr '\r' '\n')"

        # TODO: review error handling
        if [ -z "${json_data}" ]
        then
            message="Failed to replace current with new patch version in "
            message+="project configuration file ${project_config}"
            echo "${message}"
            error_flag=true
            continue
        fi

        echo "${json_data}" > "${project_config}"
    done

    target_file="${project_config}"

else

    # single-package project

    # maintain the same structure as for multi-package
    # project to allow for combined error handling
    # shellcheck disable=SC2041
    for package_name in 'dummy'
    do
        # get current patch version number and increment it
        patch_version="$(jq -r '.Version.patch' "${project_config}")"

        res="$?"

        # TODO: if [ -z "${patch_version}" ] ?
        # TODO: maintain error return value ?

        if [ "${res}" -ne 0 ]
        then
            message="Failed to get package version patch number from "
            message+=".Version.patch JSON attribute in "
            message+="project configuration file ${project_config}"
            echo "${message}"
            error_flag=true
            continue
        fi

        patch_version=$((patch_version + 1))

        # replace current with new patch version
        # TODO: using jq would be a lot simpler, but jq chooses to re-format file
        # in an arbitrary style and there seems to be now way to configure that :-(
        # json_data="$(jq ".Version.patch = \"${patch_version}\"" "${project_config}")"
        # echo "${json_data}" > "${project_config}"
        "${sed}" -i -r -e "s|${patch_regex}|\1${patch_version}\3|g" \
                          "${project_config}"

        res="$?"

        if [ "${res}" -ne 0 ]
        then
            message="Failed to replace current with new patch version in "
            message+="project configuration file ${project_config}"
            echo "${message}"
            error_flag=true
            continue
        fi
    done

    target_file="${project_config}"
fi

if [ "${error_flag}" = true ]
then
    message="Not all package patch versions were updated successfully; "
    message+="please review log output above and fix before proceeding"
    echo "${message}"
    popd > /dev/null
    exit -1
fi

# add changes to git repository
# TODO: error handling ? get log output ?

# git prints its own error messages

echo -n 'Stage changes: '
git add "${target_file}"
res="$?"; if [ "${res}" -ne 0 ]; then popd > /dev/null; exit "${res}"; fi
echo 'OK'

echo 'Commit changes:'
git commit --message "${commit_message}"
res="$?"; if [ "${res}" -ne 0 ]; then popd > /dev/null; exit "${res}"; fi


popd > /dev/null


echo
echo 'dd-update-project-version: success'
echo

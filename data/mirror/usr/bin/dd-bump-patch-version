#!/usr/bin/env bash

# dd-bump-patch-version
#
# increase version number patch level by 1
#
# author  : stefan schablowski
# contact : stefan.schablowski@desmodyne.com
# created : 2016-06-03


# MAJOR.MINOR.PATCH versioning: http://semver.org
# https://en.wikipedia.org/wiki/Software_versioning


echo
echo 'dd-bump-patch-version:'
echo

# -----------------------------------------------------------------------------
# determine platform: http://stackoverflow.com/a/18434831

# NOTE: on OS X, install GNU sed and grep using
# brew tap homebrew/dupes; brew install gnu-sed grep
# http://apple.stackexchange.com/a/69332

case "${OSTYPE}" in
    darwin*)
        # grep='ggrep'
        sed='gsed'
        ;;
    linux*)
        # grep='grep'
        sed='sed'
        ;;
    *)
        echo "Unsupported operating system: ${OSTYPE}"
        exit -1
        ;;
esac


# -----------------------------------------------------------------------------
# process command line arguments

if [ $# -ne 1 ]
then
    echo "Usage: $(basename "$0") <repository root folder>"
    exit -1
else
    if [ ! -e "$1" ]
    then
        echo "$1: No such file or directory"
        exit -1
    fi
    if [ ! -d "$1" ]
    then
        echo "$1: Not a directory"
        exit -1
    fi
fi

# -----------------------------------------------------------------------------
# configure script parameters

# absolute path to root folder of repository to process
repo_root="$(realpath "$1")"

# path to project configuration file, relative to root of target project
path_to_proj_conf='project.conf'

# regular expression pattern template for multiple lines defining patch version
multi_line_patch_regex_tmpl='("%s"[^p]*"patch" : ")([0-9]+)(")'

# regular expression pattern for line defining patch version
patch_regex='(    "patch" : ")([0-9]+)(")'

# message for committing changes to project configuration file
# TODO: add project and release names ?
commit_message='[#1]: bump patch version'


# -----------------------------------------------------------------------------
# bump patch version


# NOTE: pushd / popd require bash
pushd "${repo_root}" > /dev/null


project_config="${repo_root}/${path_to_proj_conf}"

echo "Bump patch version in ${project_config}"

# verify project configuration exists before accessing it
if [ ! -f "${project_config}" ]
then
    echo "Failed to find project configuration file: ${project_config}"
    popd > /dev/null
    exit -1
fi

# TODO: verify this works with relative paths passed as cmd line argument
# TODO: prevent processing conf of this project during development ?
# TODO: verify required executables are available before using them ?
# TODO: script return value when run as Jenkins job ?!?
# TODO: refactor this to remove code duplication
# TODO: access project config file only once

error_flag=false

if [ "$(jq '.Version.major' "${project_config}")" = 'null' ] &&
   [ "$(jq '.Version.minor' "${project_config}")" = 'null' ] &&
   [ "$(jq '.Version.patch' "${project_config}")" = 'null' ]
then

    # multi-package project

    # TODO: plausibility check against .../packages/* ?
    # TODO: package names in project.conf use _, folder names use -
    package_names="$(jq -r '.Version | keys []' "${project_config}")"

    for package_name in ${package_names}
    do
        # get current patch version number and increment it
        patch_version="$(jq -r ".Version.${package_name}.patch" \
                               "${project_config}")"

        res="$?"

        # TODO: if [ -z "${patch_version}" ] ?

        if [ "${res}" -ne 0 ]
        then
            message="Failed to get package version patch number from "
            message+=".Version.${package_name}.patch JSON attribute in "
            message+="project configuration file ${project_config}"
            echo "${message}"
            error_flag=true
            continue
        fi

        patch_version=$((patch_version + 1))

        # replace current with new patch version
        # shellcheck disable=SC2059
        patch_regex="$(printf "${multi_line_patch_regex_tmpl}" \
                              "${package_name}")"

        # http://unix.stackexchange.com/a/152389 <--- !!!
        # NOTE: it doesn't seem possible to modify the JSON file
        # in place; see also http://stackoverflow.com/a/24943373
        # NOTE: see also: http://unix.stackexchange.com/a/204378
        # shellcheck disable=SC2002
        json_data="$(cat "${project_config}" \
          | tr '\n' '\r'                     \
          | "${sed}" -r -e "s|${patch_regex}|\1${patch_version}\3|g" \
          | tr '\r' '\n')"

        # TODO: review error handling
        if [ -z "${json_data}" ]
        then
            message="Failed to replace current with new patch version in "
            message+="project configuration file ${project_config}"
            echo "${message}"
            error_flag=true
            continue
        fi

        echo "${json_data}" > "${project_config}"
    done

else

    # single-package project

    # maintain the same structure as for multi-package
    # project to allow for combined error handling
    # shellcheck disable=SC2041
    for package_name in 'dummy'
    do
        # get current patch version number and increment it
        patch_version="$(jq -r '.Version.patch' "${project_config}")"

        res="$?"

        # TODO: if [ -z "${patch_version}" ] ?
        # TODO: maintain error return value ?

        if [ "${res}" -ne 0 ]
        then
            message="Failed to get package version patch number from "
            message+=".Version.patch JSON attribute in "
            message+="project configuration file ${project_config}"
            echo "${message}"
            error_flag=true
            continue
        fi

        patch_version=$((patch_version + 1))

        # replace current with new patch version
        # TODO: using jq would be a lot simpler, but jq chooses to re-format file
        # in an arbitrary style and there seems to be now way to configure that :-(
        # json_data="$(jq ".Version.patch = \"${patch_version}\"" "${project_config}")"
        # echo "${json_data}" > "${project_config}"
        "${sed}" -i -r -e "s|${patch_regex}|\1${patch_version}\3|g" \
                          "${project_config}"

        res="$?"

        if [ "${res}" -ne 0 ]
        then
            message="Failed to replace current with new patch version in "
            message+="project configuration file ${project_config}"
            echo "${message}"
            error_flag=true
            continue
        fi
    done
fi

if [ "${error_flag}" = true ]
then
    message="Not all package patch versions were bumped successfully; "
    message+="please review log output above and fix before proceeding"
    echo "${message}"
    popd > /dev/null
    exit -1
fi

# add changes to git repository
# TODO: error handling ? get log output ?

# git prints its own error messages

echo -n 'Stage changes: '
git add "${project_config}"
res="$?"; if [ "${res}" -ne 0 ]; then popd > /dev/null; exit "${res}"; fi
echo 'OK'

echo 'Commit changes:'
git commit --message "${commit_message}"
res="$?"; if [ "${res}" -ne 0 ]; then popd > /dev/null; exit "${res}"; fi


popd > /dev/null


echo
echo 'dd-bump-patch-version: success'
echo

#!/usr/bin/env bash

# dd-finish-release
#
# finish a software release
#
# author  : stefan schablowski
# contact : stefan.schablowski@desmodyne.com
# created : 2016-06-04


echo
echo 'dd-finish-release:'
echo

# -----------------------------------------------------------------------------
# process command line arguments

if [ $# -ne 1 ]
then
    echo "Usage: $(basename "$0") <repository root folder>"
    exit -1
else
    if [ ! -e "$1" ]
    then
        echo "$1: No such file or directory"
        exit -1
    fi
    if [ ! -d "$1" ]
    then
        echo "$1: Not a directory"
        exit -1
    fi
fi

# TODO: prevent processing repo this file is in during development ?
# TODO: verify required executables are available before using them ?
# TODO: script return value when run as Jenkins job ?!?
# TODO: add leading zero to calender week in release name
# TODO: get release name from git branch ? plausibility checks ?
# TODO: sign the release tag cryptographically ? https://github.com/nvie/ ...
# gitflow/wiki/Command-Line-Arguments#git-flow-release-finish--fsumpkn-version
# TODO: do something with the output when script succeeds, e.g.
# Finishing release 2016.21 in <path to project root>:
# Switched to branch 'master'
# Your branch is up-to-date with 'origin/master'.
# Merge made by the 'recursive' strategy.
#  build/CMakeLists.txt                                     |  2 +-
#  doc/txt/Release Notes/20160604 Release Notes 2016.21.txt | 17 +++++++++++++++++
#  2 files changed, 18 insertions(+), 1 deletion(-)
#  create mode 100644 doc/txt/Release Notes/20160604 Release Notes 2016.21.txt
# Switched to branch 'develop'
# Your branch is up-to-date with 'origin/develop'.
# Merge made by the 'recursive' strategy.
#  build/CMakeLists.txt                                     |  2 +-
#  doc/txt/Release Notes/20160604 Release Notes 2016.21.txt | 17 +++++++++++++++++
#  2 files changed, 18 insertions(+), 1 deletion(-)
#  create mode 100644 doc/txt/Release Notes/20160604 Release Notes 2016.21.txt
# Deleted branch release/2016.21 (was 14cc582).
#
# Summary of actions:
# - Latest objects have been fetched from 'origin'
# - Release branch has been merged into 'master'
# - The release was tagged '2016.21'
# - Release branch has been back-merged into 'develop'
# - Release branch 'release/2016.21' has been deleted


# -----------------------------------------------------------------------------
# configure script parameters

# absolute path to the root folder of the repository to process
repo_root="$(realpath "$1")"

# name of default git repo remote
default_remote_name='origin'

# name of branch for next release development;
# 'develop' as per git flow convention
develop_branch='develop'

# regular expression to match branch name for
# next release development in 'git branch' output
local_develop_regex="^[ |*] ${develop_branch}$"

# same as above, but for remote branches
remote_develop_regex="^  ${default_remote_name}/${develop_branch}$"

# name of branch for production releases;
# 'master' as per git flow convention
master_branch='master'

# release branch prefix; 'release' as per git flow convention
rel_prefix='release'

# regular expression to match branch name for
# production releases in 'git branch' output
local_master_regex="^[ |*] ${master_branch}$"

# same as above, but for remote branches
remote_master_regex="^  ${default_remote_name}/${master_branch}$"

# message for creating release tag
# TODO: add project and release names ?
# TODO: on OSX, getopt fails on spaces, even
# with extra / escaped single / double quotes:
# https://github.com/nvie/gitflow/issues/98
# TODO: does this also occur on on Linux ?
tag_message='automatically_created_release_tag'

# the message of an expectable and recoverable error
err_msg_git_flow_init='Fatal: Not a gitflow-enabled repo yet. ' \
err_msg_git_flow_init+="Please run 'git flow init' first."


# NOTE: pushd / popd require bash
pushd "${repo_root}" > /dev/null


# -----------------------------------------------------------------------------
# finish the release

# name of the release in progress
# TODO: this assumes there is only one local release branch at a time - which is
# reasonable as git flow refuses to start a release if there is already one
release_name="$(git branch | grep "^[*| ] ${rel_prefix}" | cut -d / -f 2)"

if [ -z "${release_name}" ]
then
    echo "Failed to determine name of current release"
    exit -1
fi

echo -n "Finish release ${release_name} in ${repo_root}: "

# http://stackoverflow.com/q/14531243
# https://github.com/nvie/gitflow/pull/287
# echo "GIT_MERGE_AUTOEDIT: ${GIT_MERGE_AUTOEDIT}"
# TODO: store value before setting it; restore after use
export GIT_MERGE_AUTOEDIT=no
# echo "GIT_MERGE_AUTOEDIT: ${GIT_MERGE_AUTOEDIT}"

# TODO: on OS X, getopt fails if options such as the tag message contain spaces:
#   flags:FATAL the available getopt does not support spaces in options
# workaround does not fix this either: https://github.com/nvie/gitflow/issues/98
# brew install gnu-getopt
# FLAGS_GETOPT_CMD: /usr/local/opt/gnu-getopt/bin/getopt
# alexa:bin ssc$ /usr/local/opt/gnu-getopt/bin/getopt --version
# getopt (enhanced) 1.1.6
# alexa:bin ssc$ which getopt
# /usr/bin/getopt
# alexa:bin ssc$ /usr/bin/getopt --version
#  --
#
# echo "FLAGS_GETOPT_CMD: ${FLAGS_GETOPT_CMD}"
# export FLAGS_GETOPT_CMD="$(brew --prefix gnu-getopt)/bin/getopt"
# echo "FLAGS_GETOPT_CMD: ${FLAGS_GETOPT_CMD}"

# NOTE: in git, -m and --message are equivalent;
# git flow fails on the long version --message:
# flags:WARN getopt: illegal option -- -
#  -m essage -- automatically_created_release_tag 2016.21
# flags:FATAL unable to parse provided options with getopt.

# TODO: investigate and recover from or prepare for
# master and origin/master having diverged

output=$(git flow release finish -m "${tag_message}" "${release_name}" 2>&1)

res="$?"

# NOTE: there isn't really a need to use a while loop here;
# this is just done for consistency with dd-start-release

recovered=false

while [ "${res}" -ne 0 ]
do
    recovered=true
    echo

    case "${output}" in

        "${err_msg_git_flow_init}")

            # NOTE: see dd-start-release for more information

            echo "Not a gitflow-enabled repo yet, need to run 'git flow init'."
            echo "Verify preconditions for unattended 'git flow init' execution:"
            echo

            local_branches="$(git branch)"

            echo -n "Production release branch (${master_branch}): "

            if echo "${local_branches}" | grep -q "${local_master_regex}"
            then
                echo 'OK'
            else
                echo 'not found'
                echo 'Attempt to check it out from default remote:'
                remote_branches="$(git branch -r)"

                if echo "${remote_branches}" | grep -q "${remote_master_regex}"
                then
                    echo "git checkout ${master_branch}"
                    git checkout "${master_branch}"
                    res="$?"; if [ "${res}" -ne 0 ]; then popd > /dev/null; exit "${res}"; fi
                    echo
                else
                    echo "Failed to obtain ${master_branch} from ${default_remote_name}"
                    exit -1
                fi
            fi

            echo -n "Next release development branch (${develop_branch}): "

            if echo "${local_branches}" | grep -q "${local_develop_regex}"
            then
                echo 'OK'
                echo
            else
                echo 'not found'
                echo 'Attempt to check it out from default remote:'
                remote_branches="$(git branch -r)"

                if echo "${remote_branches}" | grep -q "${remote_develop_regex}"
                then
                    echo "git checkout ${develop_branch}"
                    git checkout "${develop_branch}"
                    res="$?"; if [ "${res}" -ne 0 ]; then popd > /dev/null; exit "${res}"; fi
                    echo
                else
                    echo "Failed to obtain ${develop_branch} from ${default_remote_name}"
                    exit -1
                fi
            fi

            echo "Preconditions verified; run 'git flow init':"

            git flow init -d
            res="$?"; if [ "${res}" -ne 0 ]; then popd > /dev/null; exit "${res}"; fi

            echo
            echo "Again, finish release ${release_name} in ${repo_root}:"

            output=$(git flow release finish -m "${tag_message}" "${release_name}" 2>&1)
            res="$?"

            ;;

        *)
            # git flow release finish prints its own error messages
            echo "${output}"
            popd > /dev/null
            exit "${res}"
    esac
done

if [ "${recovered}" = false ]
then
    echo 'OK'
fi

export GIT_MERGE_AUTOEDIT=


popd > /dev/null


echo
echo 'dd-finish-release: success'
echo

#!/usr/bin/env bash

# dd-start-release
#
# start a software release
#
# author  : stefan schablowski
# contact : stefan.schablowski@desmodyne.com
# created : 2016-06-01


echo
echo 'dd-start-release:'
echo

# -----------------------------------------------------------------------------
# process command line arguments

if [ $# -ne 1 ]
then
    echo "Usage: $(basename "$0") <repository root folder>"
    exit -1
else
    if [ ! -e "$1" ]
    then
        echo "$1: No such file or directory"
        exit -1
    fi
    if [ ! -d "$1" ]
    then
        echo "$1: Not a directory"
        exit -1
    fi
fi

# TODO: prevent processing repo this file is in during development ?
# TODO: verify required executables are available before using them ?
# TODO: script return value when run as Jenkins job ?!?
# TODO: verify release branch to create does not exist on remote yet ?
# TODO: add leading zero to calender week in release name
# TODO: do something with the output when script succeeds, e.g.
# Creating release 2016.21 in <path to project root>:
# Switched to a new branch 'release/2016.21'
#
# Summary of actions:
# - A new branch 'release/2016.21' was created, based on 'develop'
# - You are now on branch 'release/2016.21'
#
# Follow-up actions:
# - Bump the version number now!
# - Start committing last-minute fixes in preparing your release
# - When done, run:
#
#      git flow release finish '2016.21'


# -----------------------------------------------------------------------------
# configure script parameters

# absolute path to the root folder of the repository to process
repo_root="$(realpath "$1")"

# name of default git repo remote
default_remote_name='origin'

# name of branch for next release development;
# 'develop' as per git flow convention
develop_branch='develop'

# regular expression to match branch name for
# next release development in 'git branch' output
local_develop_regex="^[ |*] ${develop_branch}$"

# same as above, but for remote branches
remote_develop_regex="^  ${default_remote_name}/${develop_branch}$"

# name of branch for production releases;
# 'master' as per git flow convention
master_branch='master'

# regular expression to match branch name for
# production releases in 'git branch' output
local_master_regex="^[ |*] ${master_branch}$"

# same as above, but for remote branches
remote_master_regex="^  ${default_remote_name}/${master_branch}$"

# name of the release, follows YYYY.CW pattern; as a release is created to
# publish the efforts of the past week, the calender week is that of last week;
# if a release tag with that name already exists; a new release name is tried
# by appending .01, .02, .03, etc. until one that doesn't exist is found
# TODO: this is calculated this way several times and should come from elsewhere
canonical_release_name="$(date +"%Y").$(( $(date +"%V") - 1))"

# TODO: document for the team that under OSX, git-flow-avh must be installed,
# not git-flow; the latter causes this script to fail due to one stupid bug:
#
# message on Linux, 1.8.0 (AVH Edition) installed using aptitude install git-flow:
#   Fatal: Not a gitflow-enabled repo yet. Please run 'git flow init' first.
# message on OSX, version 0.4.1, installed using brew install git-flow:
#   fatal: Not a gitflow-enabled repo yet. Please run "git flow init" first.
# message on OSX, 1.9.1 (AVH Edition), installed using brew install git-flow-avh:
#   fatal: Not a gitflow-enabled repo yet. Please run "git flow init" first.

# the message of an expectable and recoverable error
err_msg_git_flow_init='Fatal: Not a gitflow-enabled repo yet. ' \
err_msg_git_flow_init+="Please run 'git flow init' first."

# template for the message of another expectable and recoverable error
err_msg_tag_already_exists_tmpl="Fatal: Tag '%s' already exists. " \
err_msg_tag_already_exists_tmpl+='Pick another name.'


# NOTE: pushd / popd require bash
pushd "${repo_root}" > /dev/null


# -----------------------------------------------------------------------------
# start the release

release_name="${canonical_release_name}"

echo "Start release ${release_name} in ${repo_root}:"
# this assumes git prints to either stdout or stderr,
# but not both - and sets a corresponding return value
output=$(git flow release start "${release_name}" 2>&1)

# TODO: deal with _release_ (not _tag_) already existing, e.g.
# Fatal: Branch 'release/2016.24.02' already exists. Pick another name.

res="$?"

while [ "${res}" -ne 0 ]
do
    # shellcheck disable=SC2059
    err_msg_tag_already_exists="$(printf "${err_msg_tag_already_exists_tmpl}" \
                                         "${release_name}")"

    case "${output}" in

        "${err_msg_git_flow_init}")

            # NOTE: git flow init requires local develop and master branches to be
            # present locally to auto-select them for fully unattended execution

            # TODO: the above does not seem to be the case for a brand new repo:
            # ssc@vm-build-debian-stable-ssc:~$ cd /tmp
            # ssc@vm-build-debian-stable-ssc:/tmp$ mkdir test
            # ssc@vm-build-debian-stable-ssc:/tmp$ cd test
            # ssc@vm-build-debian-stable-ssc:/tmp/test$ git init
            # Initialized empty Git repository in /tmp/test/.git/
            # ssc@vm-build-debian-stable-ssc:/tmp/test$ git flow init -d
            # Using default branch names.
            # No branches exist yet. Base branches must be created now.
            # Branch name for production releases: [master]
            # Branch name for "next release" development: [develop]
            #
            # How to name your supporting branch prefixes?
            # Feature branches? [feature/]
            # Release branches? [release/]
            # Hotfix branches? [hotfix/]
            # Support branches? [support/]
            # Version tag prefix? []
            # Hooks and filters directory? [/tmp/test/.git/hooks]

            echo "Not a gitflow-enabled repo yet, need to run 'git flow init'."
            echo "Verify preconditions for unattended 'git flow init' execution:"
            echo

            local_branches="$(git branch)"

            # TODO: remove this
            # printf "local_branches:\n%s\n" "${local_branches}"

            # NOTE: bash regex doesn't seem to support matching
            # line ends within a multi-line search string:
            # if [[ "${local_branches}" =~ "${local_master_regex}" ]]

            echo -n "Production release branch (${master_branch}): "

            # https://github.com/koalaman/shellcheck/wiki/SC2143
            if echo "${local_branches}" | grep -q "${local_master_regex}"
            then
                echo 'OK'
            else
                echo 'not found'
                echo 'Attempt to check it out from default remote:'
                remote_branches="$(git branch -r)"

                # TODO: remove this
                # printf "remote_branches:\n%s\n" "${remote_branches}"
                # echo "remote_master_regex: ${remote_master_regex}"

                # need to test if remote branch exists first in order not to create
                # a new independent branch or get into a  'detached HEAD' state
                if echo "${remote_branches}" | grep -q "${remote_master_regex}"
                then
                    echo "git checkout ${master_branch}"
                    git checkout "${master_branch}"
                    res="$?"; if [ "${res}" -ne 0 ]; then popd > /dev/null; exit "${res}"; fi
                    echo
                else
                    echo "Failed to obtain ${master_branch} from ${default_remote_name}"
                    exit -1
                fi
            fi

            echo -n "Next release development branch (${develop_branch}): "

            if echo "${local_branches}" | grep -q "${local_develop_regex}"
            then
                echo 'OK'
                echo
            else
                echo 'not found'
                echo 'Attempt to check it out from default remote:'
                remote_branches="$(git branch -r)"

                # TODO: remove this
                # printf "remote_branches:\n%s\n" "${remote_branches}"
                # echo "remote_develop_regex: ${remote_develop_regex}"

                # need to test if remote branch exists first in order not to create
                # a new independent branch or get into a  'detached HEAD' state
                if echo "${remote_branches}" | grep -q "${remote_develop_regex}"
                then
                    echo "git checkout ${develop_branch}"
                    git checkout "${develop_branch}"
                    res="$?"; if [ "${res}" -ne 0 ]; then popd > /dev/null; exit "${res}"; fi
                    echo
                else
                    echo "Failed to obtain ${develop_branch} from ${default_remote_name}"
                    exit -1
                fi
            fi

            echo "Preconditions verified; run 'git flow init':"

            # -d : use default branch names
            git flow init -d
            res="$?"; if [ "${res}" -ne 0 ]; then popd > /dev/null; exit "${res}"; fi

            echo
            echo "Again, start release ${release_name} in ${repo_root}:"

            output=$(git flow release start "${release_name}" 2>&1)
            res="$?"

            ;;

        "${err_msg_tag_already_exists}")

            message="$(printf "Release tag '%s'" "${release_name}")"
            message+=' already exists, need to pick another name.'
            echo "${message}"

            if [ "${release_name}" = "${canonical_release_name}" ]
            then
                release_name="${canonical_release_name}.01"
            else
                # TODO: this strongly relies on 2016.25.01 pattern
                counter="$(echo "${release_name}" | cut -d . -f 3)"
                counter=$((counter+1))
                release_name="${canonical_release_name}.$(printf "%02d" ${counter})"
            fi

            echo
            echo "Start release with new name ${release_name} in ${repo_root}:"

            output=$(git flow release start "${release_name}" 2>&1)
            res="$?"

            ;;

        *)
            # git flow release start prints its own error messages
            echo "${output}"
            popd > /dev/null
            exit "${res}"
    esac
done

echo "${output}"


popd > /dev/null


echo
echo 'dd-start-release: success'
echo

#!/usr/bin/env bash

# dd-create-release-notes
#
# create release notes
#
# author  : stefan schablowski
# contact : stefan.schablowski@desmodyne.com
# created : 2016-06-03


# -----------------------------------------------------------------------------
# determine platform: http://stackoverflow.com/a/18434831

# NOTE: on OS X, install GNU sed and grep using
# brew tap homebrew/dupes; brew install gnu-sed grep
# http://apple.stackexchange.com/a/69332

case "${OSTYPE}" in
    darwin*)
        grep='ggrep'
        sed='gsed'
        ;;
    linux*)
        grep='grep'
        sed='sed'
        ;;
    *)
        echo "Unsupported operating system: ${OSTYPE}"
        exit -1
        ;;
esac


# -----------------------------------------------------------------------------
# process command line arguments

if [ $# -ne 1 ]
then
    echo "Usage: $(basename "$0") <repository root folder>"
    exit -1
else
    if [ ! -e "$1" ]
    then
        echo "$1: No such file or directory"
        exit -1
    fi
    if [ ! -d "$1" ]
    then
        echo "$1: Not a directory"
        exit -1
    fi
fi

# TODO: prevent processing repo this file is in during development ?
# TODO: verify required executables are available before using them ?
# TODO: script return value when run as Jenkins job ?!?
# TODO: test this with projects that don't have any releases yet
# TODO: verify most recent release was merged to master ?!?
# TODO: perform git branch status plausibility checks elsewhere


# -----------------------------------------------------------------------------
# configure script parameters

# absolute path to root folder of repository to process
repo_root="$(realpath "$1")"

# release branch prefix; 'release' as per git flow convention
rel_prefix='release'

# path to folder where release notes will be stored,
# relative to root folder of repository to process
output_folder='doc/txt/Release Notes'

# name of the generated release notes file;
# release name will be amended further below
output_filename="$(date +"%Y%m%d") Release Notes <release name>.txt"

# message for committing release notes
# TODO: add project and release names ?
commit_message='[#1]: add release notes'


# NOTE: pushd / popd require bash
pushd "${repo_root}" > /dev/null


# -----------------------------------------------------------------------------
# create release notes

echo "Create release notes in ${repo_root}:"

# create output folder if required
if [ ! -d "${output_folder}" ]
then
    mkdir -p "${output_folder}"
fi

# verify target project is on a release branch
current_branch="$(git branch | "${grep}" '^* ' | "${sed}" -e 's|* ||g')"

if [ -z "${current_branch}" ]
then
    echo "Failed to determine current branch"
    popd > /dev/null
    exit -1
fi

# http://stackoverflow.com/a/229606
if [[ "${current_branch}" != *"${rel_prefix}"* ]]
then
    message="Project in ${repo_root} is not on a ${rel_prefix} branch, "
    message+="but on ${current_branch}; please start a release first"
    echo "${message}"
    popd > /dev/null
    exit -1
fi

# verify target project is on the latest release branch
# TODO: is there a need to take local release branches into consideration ?
# if dd-start-release is run with local release branches being present,
# git flow aborts with a message like for example
#   There is an existing release branch (2016.08.a ...
#    ... release/2016.20.a release/2016.21.a). Finish that one first.
# if dd-start-release is run with local release tag being present,
# git flow aborts with a message like for example
#   Tag '2016.21' already exists. Pick another name.

latest_branch=$(git branch -a | "${grep}" "${rel_prefix}" \
                    | "${sed}" -r -e "s|^.*${rel_prefix}|${rel_prefix}|g" \
                    | sort | uniq | tail -n 1)

if [ -z "${latest_branch}" ]
then
    echo "Failed to determine latest release branch"
    popd > /dev/null
    exit -1
fi

if [[ "${current_branch}" != "${latest_branch}" ]]
then
    message="Project in ${repo_root} is not on the latest release branch "
    message+="${latest_branch} but on ${current_branch}; please update first"
    echo "${message}"
    popd > /dev/null
    exit -1
fi

# get commit SHA1 hashes of previous and this release branch
# TODO: make master and HEAD configurable ?
prev_release="$(git rev-parse --verify master)"
res="$?"; if [ "${res}" -ne 0 ]; then popd > /dev/null; exit "${res}"; fi
this_release="$(git rev-parse --verify HEAD)"
res="$?"; if [ "${res}" -ne 0 ]; then popd > /dev/null; exit "${res}"; fi

# https://github.com/koalaman/shellcheck/wiki/SC2001
current_branch="${current_branch//${rel_prefix}\//}"
output_filename="${output_filename//<release name>/${current_branch}}"

# TODO: --format=format:<string> ?
# TODO: internal / external release notes ?
# TODO: make order and format configurable ?

git rev-list --topo-order --format=fuller \
   "${prev_release}".."${this_release}"   \
 > "${output_folder}/${output_filename}"
 res="$?"; if [ "${res}" -ne 0 ]; then popd > /dev/null; exit "${res}"; fi


# add and commit changes to git repository
# TODO: error handling ? get log output ?

git add "${output_folder}/${output_filename}"
res="$?"; if [ "${res}" -ne 0 ]; then popd > /dev/null; exit "${res}"; fi
git commit --message "${commit_message}"
res="$?"; if [ "${res}" -ne 0 ]; then popd > /dev/null; exit "${res}"; fi


popd > /dev/null
